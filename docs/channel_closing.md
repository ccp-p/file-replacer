# Go 通道关闭的最佳实践

在 Go 并发编程中，安全地关闭通道是一个重要考虑点。下面详细解释关闭通道的模式及其重要性。

## 关闭通道的挑战

在 Go 中关闭通道有几个重要原则：

1. **向已关闭的通道发送数据会引起 panic**
2. **重复关闭通道同样会引起 panic**
3. **从已关闭的通道接收会立即返回零值，而不会阻塞**

因此，需要确保在所有发送者完成发送后才关闭通道，且只关闭一次。

## 代码模式解析

```go
go func() {
    wg.Wait()
    close(results)
}()
```

这个模式的工作流程：

1. 创建一个额外的"监视"协程
2. 这个协程使用 `wg.Wait()` 等待所有生产者完成工作
3. 确认所有生产者都不会再发送数据后，安全地关闭通道
4. 这样消费者协程在处理完所有数据后会自然退出循环

## 为何不在主协程关闭?

如果按下面方式编写：

```go
// 错误示范！
for i := 1; i <= 5; i++ {
    go worker(i)
}
// ... 主协程做其他事情
close(results) // 危险！无法保证所有 worker 都完成了发送
```

这会导致通道可能在某些生产者还未完成发送前就被关闭，导致 panic。

## 为何不在最后一个生产者关闭?

确定"最后一个"生产者通常很困难，特别是当任务处理时间不同或动态生成时。

## WaitGroup 的作用

`sync.WaitGroup` 提供了一种优雅的方式来跟踪并发任务的完成情况：

1. 在启动每个生产者前调用 `wg.Add(1)` 
2. 每个生产者完成后调用 `wg.Done()`
3. 监视协程通过 `wg.Wait()` 等待所有生产者完成

这样就能确保通道关闭时所有发送操作都已完成。
