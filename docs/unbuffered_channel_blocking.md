# Go 无缓冲通道的阻塞机制详解

## 什么是无缓冲通道？

无缓冲通道（`make(chan T)`）是 Go 语言中的一种同步原语，它具有以下核心特性：

- **不具备存储能力**：无缓冲通道没有内部存储空间
- **同步传递**：发送和接收操作必须同时就绪才能完成
- **阻塞特性**：如果没有对应的接收方，发送操作会阻塞；如果没有对应的发送方，接收操作会阻塞

## 无缓冲通道的阻塞行为

### 关键理解点：

* **发送操作会阻塞**，直到有另一个协程准备接收
* **接收操作会阻塞**，直到有另一个协程准备发送

这就像一次握手 - 两边必须同时在场才能完成交流。

## "准备发送" 与 "已发送" 的区别

在我们的演示代码中：

```go
fmt.Printf("协程 %d: 准备发送结果 (阻塞前)\n", id)
resultChan <- fmt.Sprintf("结果 %d", id)  // 阻塞发生在这里!
fmt.Printf("协程 %d: 已发送结果 (阻塞后)\n", id)
```

这段代码的执行过程：

1. 首先打印 "准备发送结果"
2. 尝试发送数据到通道
3. 发送操作阻塞，协程暂停在这一行
4. **只有**当另一个协程从通道接收数据时，发送操作才会完成
5. 发送完成后，才会打印 "已发送结果"

## 无人接收的后果 - 协程泄漏

在我们的泄漏演示中，只有5个接收操作，但有10个发送操作。这意味着：

- 5个协程能够成功发送并完成（打印"已发送结果"）
- 另外5个协程将**永远阻塞**在发送操作上（永远不会打印"已发送结果"）

这就是协程泄漏的一种形式 - 协程被创建但永远不会终止，消耗系统资源。

## 缓冲通道与无缓冲通道的区别

对比无缓冲通道和有缓冲通道（例如 `make(chan T, 5)`）：

| 特性 | 无缓冲通道 | 有缓冲通道 |
|------|------------|------------|
| 容量 | 0 | N (N > 0) |
| 发送行为 | 阻塞直到有人接收 | 仅当缓冲区满时阻塞 |
| 接收行为 | 阻塞直到有数据可接收 | 仅当缓冲区空时阻塞 |
| 同步性质 | 强同步（类似直接转交） | 弱同步（类似邮箱） |

## 小结

无缓冲通道的核心特性是其同步特性 - 它强制发送者和接收者在时间上"相遇"。正是这种特性使其成为协程间同步的有力工具，但也是可能导致阻塞和泄漏的原因。
