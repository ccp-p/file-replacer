# Go 并发模型说明

我们的项目中实现了两种不同的并发处理模式。这里详细说明这两种模型的特点、适用场景以及优缺点。

## 1. 基于有缓冲通道的工作池模式

### 实现原理

```go
// 创建任务通道
taskChan := make(chan Task, taskCount)
// 填充任务
for _, task := range tasks {
    taskChan <- task
}
close(taskChan)

// 创建工作协程池
for i := 0; i < workerCount; i++ {
    go worker(taskChan)
}
```

### 特点

- **预先分配所有任务**: 所有任务在开始时就加入队列
- **固定数量的工作协程**: 控制并发度
- **任务动态分配**: 忙的工作协程少处理任务，闲的多处理
- **适用于处理大量同质小任务**: 如我们的文件替换任务

### 优点

- 控制资源使用，防止过多协程导致内存占用过高
- 任务自动负载均衡
- 实现简单，维护方便

### 缺点

- 需要预先知道所有任务
- 对于处理时间差异大的任务可能效率不高

## 2. 基于无缓冲通道的结果收集模式

### 实现原理

```go
// 创建结果通道
resultChan := make(chan Result)

// 为每个任务启动协程
for _, task := range tasks {
    go func(t Task) {
        result := process(t)
        resultChan <- result // 阻塞直到结果被接收
    }(task)
}

// 接收结果
for i := 0; i < len(tasks); i++ {
    result := <-resultChan
    // 处理结果
}
```

### 特点

- **每个任务一个协程**: 任务并行度高
- **实时结果处理**: 一旦任务完成立即获得结果
- **结果顺序不确定**: 先完成的任务先返回结果
- **通常需要信号量限制并发**: 防止协程过多

### 优点

- 非常适合异构任务（处理时间差异大）
- 响应速度快，可以立即开始处理完成的结果
- 适合需要即时处理结果的场景

### 缺点

- 如果任务数量很多，可能创建过多协程
- 需要额外的同步机制管理通道关闭
- 实现相对复杂

## 在我们的项目中

- **replacer.go** 使用了工作池模式，适合处理大量文件
- **unbuffered_replacer.go** 展示了无缓冲通道模式的替代实现

根据实际需求和系统资源情况，可以选择适合的并发模型。通常：

- 处理大量小文件时，工作池模式更高效
- 处理少量大文件时，无缓冲通道模式可能更合适
