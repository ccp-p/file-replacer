# 不使用 WaitGroup 的通道模式分析

## 您的代码

```go
resultChan := make(chan Result)
// 启动工作线程
for _, task := range tasks {
    go func(t Task) {
        result := processTask(t)
        resultChan <- result  // 将结果发送到通道
    }(task)
}
// 收集所有结果
for i := 0; i < len(tasks); i++ {
    result := <-resultChan
    handleResult(result)
}
```

## 这种模式是否可行？

**是的**，这种模式确实可以工作，您没有必要在每种情况下都使用 WaitGroup。

## 那么为什么有时候需要 WaitGroup？

不使用 WaitGroup 的方案在以下情况下可能会有问题：

### 1. 通道关闭问题

如果您需要在循环之外继续使用 `resultChan`，例如用 `for result := range resultChan` 接收结果，您需要某种方式来确定何时安全地关闭通道。WaitGroup 提供了这种机制。

### 2. 任务数量不固定

如果任务数量在运行时确定或动态变化，简单地用 `for i := 0; i < len(tasks); i++` 可能不足以收集所有结果。

### 3. 程序提前退出的风险

如果任务处理时间变化很大，而程序逻辑复杂，可能会在所有协程完成前就退出主函数，导致某些协程泄漏。

### 4. 结果处理不完整

如果只接收部分结果就退出循环，会导致一些协程阻塞在发送操作上，因为无人接收它们的结果。

## 您的代码在什么情况下是安全的？

您的代码在以下条件下是完全安全的：

1. 任务数量是固定的且已知的（正如您的例子）
2. 您确保为每个任务接收一个结果
3. 不需要明确关闭通道

## 什么情况下应该使用 WaitGroup？

1. 当您需要确定所有协程都已完成
2. 当您需要安全地关闭通道
3. 当任务数量可能变化或不确定时
4. 当您需要在所有协程完成后执行一些操作，但不一定需要收集所有结果

## 结论

您的代码模式对于简单场景是完全有效的。WaitGroup 不是"多此一举"，而是为更复杂的情况提供了安全保障。选择哪种方式取决于您的具体需求和程序复杂度。
